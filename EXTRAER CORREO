import win32com.client
import pandas as pd
import re
import os
import datetime

def limpiar_html(texto_sucio):
    if not texto_sucio: return ""
    texto = texto_sucio.replace('&nbsp;', ' ').replace('&amp;', '&').replace('&gt;', '>').replace('&lt;', '<')
    texto_limpio = re.sub(r'<[^>]+>', '', texto)
    return texto_limpio.replace('\r', '').replace('\n', '').strip()

def detectar_tipo_tabla(texto_previo):
    if not texto_previo: return "NORMAL"
    texto_upper = texto_previo.upper()
    idx_testeo = texto_upper.rfind("TESTEO")
    idx_afectacion = texto_upper.rfind("AFECTACION")
    if idx_afectacion == -1: idx_afectacion = texto_upper.rfind("AFECTACIÓN")

    if idx_testeo == -1 and idx_afectacion == -1: return "NORMAL"
    if idx_testeo > idx_afectacion: return "TESTEO"
    else: return "AFECTACION"

def verificar_excel_cerrado(ruta_excel):
    """Verifica si el archivo está libre para escribir."""
    if os.path.exists(ruta_excel):
        try:
            with open(ruta_excel, "a"):
                pass
        except PermissionError:
            return False
    return True

def procesar_correos_bancarios_v7():
    archivo_excel = "Base_Fraude_Comercios_Final.xlsx"
    
    print("--- INICIANDO ESCANEO (VERSIÓN 7 - ORDEN CRONOLÓGICO) ---")

    # 1. VERIFICACIÓN DE SEGURIDAD
    if not verificar_excel_cerrado(archivo_excel):
        print("\n" + "="*50)
        print("❌ ERROR CRÍTICO: EL EXCEL ESTÁ ABIERTO")
        print(f"Cierra '{archivo_excel}' y vuelve a ejecutar.")
        print("="*50 + "\n")
        return

    try:
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        inbox = outlook.GetDefaultFolder(6) 
        carpeta_destino = inbox.Folders("deteccion") 
    except Exception as e:
        print("Error conectando a Outlook.")
        return

    items = carpeta_destino.Items
    
    # --- CAMBIO 1: Ordenamos Outlook para leer del MÁS ANTIGUO al MÁS NUEVO ---
    # False = Ascendente (Viejo -> Nuevo). Así se procesan en el orden correcto.
    items.Sort("[ReceivedTime]", False) 
    
    mensajes_filtrados = items.Restrict("[UnRead] = True")
    lista_mensajes = list(mensajes_filtrados)
    
    cantidad = len(lista_mensajes)
    print(f"Total de correos NO LEÍDOS: {cantidad}")

    if cantidad == 0:
        print("No hay nada pendiente.")
        return

    lista_datos = []
    mensajes_para_marcar = [] 

    # 2. PROCESAR CADA CORREO
    for i, mensaje in enumerate(lista_mensajes):
        try:
            print(f"Leyendo correo {i+1}/{cantidad} ({mensaje.ReceivedTime})...")
            html_body = mensaje.HTMLBody
            fecha_obj = mensaje.ReceivedTime
            
            # Formatos string para guardar
            fecha_str = fecha_obj.strftime("%d/%m/%Y")
            hora_str = fecha_obj.strftime("%H:%M:%S")

            tablas_encontradas = list(re.finditer(r'<table[^>]*>(.*?)</table>', html_body, re.IGNORECASE | re.DOTALL))
            datos_encontrados = False

            for match_tabla in tablas_encontradas:
                start_index = match_tabla.start()
                contenido_tabla = match_tabla.group(1)
                texto_previo = html_body[:start_index]
                tipo_detectado = detectar_tipo_tabla(texto_previo)
                filas = re.split(r'</tr>', contenido_tabla, flags=re.IGNORECASE)

                for fila in filas:
                    celdas = re.findall(r'<td[^>]*>(.*?)</td>', fila, re.IGNORECASE | re.DOTALL)
                    if len(celdas) < 2: continue
                    columna_0 = limpiar_html(celdas[0])
                    columna_1 = limpiar_html(celdas[1])
                    
                    if not columna_0: continue
                    if "NOMBRE COMERCIO" in columna_0.upper() or "Q TRX" in columna_0.upper(): continue
                    if "COD" in columna_1.upper() and "COMERCIO" in columna_1.upper(): continue
                    if "ENTRY" in columna_1.upper() or "TOTAL" in columna_0.upper(): continue

                    lista_datos.append({
                        "Fecha": fecha_str,
                        "Hora": hora_str,
                        "Tipo": tipo_detectado,
                        "Nombre_Comercio": columna_0,
                        "Codigo_Comercio": columna_1
                    })
                    datos_encontrados = True
            
            if datos_encontrados:
                mensajes_para_marcar.append(mensaje)

        except Exception as e:
            print(f"Error en correo {i+1}: {e}")
            continue

    # 3. GUARDAR Y ORDENAR EN EXCEL
    if lista_datos:
        df_nuevo = pd.DataFrame(lista_datos)
        columnas_orden = ["Fecha", "Hora", "Tipo", "Nombre_Comercio", "Codigo_Comercio"]
        df_nuevo = df_nuevo[columnas_orden]

        guardado_exitoso = False
        
        try:
            if os.path.exists(archivo_excel):
                try:
                    df_antiguo = pd.read_excel(archivo_excel)
                    df_final = pd.concat([df_antiguo, df_nuevo], ignore_index=True)
                except:
                    df_final = df_nuevo
            else:
                df_final = df_nuevo
            
            # --- CAMBIO 2: ORDENAMIENTO ESTRICTO ---
            print("Ordenando base de datos cronológicamente...")
            
            # Creamos una columna temporal combinando Fecha y Hora para ordenar correctamente
            # Usamos dayfirst=True para asegurar que lea día/mes/año correctamente
            df_final["_temp_sort"] = pd.to_datetime(
                df_final["Fecha"].astype(str) + " " + df_final["Hora"].astype(str), 
                dayfirst=True, 
                errors='coerce' # Si hay algún error, no rompe el código
            )
            
            # Ordenamos: Ascending=True pone lo antiguo arriba y lo nuevo abajo
            df_final = df_final.sort_values("_temp_sort", ascending=True)
            
            # Borramos la columna temporal
            df_final = df_final.drop(columns=["_temp_sort"])

            # Guardamos
            df_final.to_excel(archivo_excel, index=False)
            guardado_exitoso = True
            print(f"✅ ¡ÉXITO! Se agregaron y ordenaron {len(lista_datos)} registros.")
            
        except PermissionError:
            print("\n❌ ERROR: EL EXCEL SIGUE ABIERTO. CIÉRRALO.")
        
        # 4. MARCAR COMO LEÍDO
        if guardado_exitoso:
            print("Actualizando estado de correos...")
            for m in mensajes_para_marcar:
                try:
                    m.UnRead = False
                    m.Save()
                except:
                    pass
            print("Todo listo.")
            
    else:
        print("No se encontraron datos nuevos válidos.")

if __name__ == "__main__":
    procesar_correos_bancarios_v7()
