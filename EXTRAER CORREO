import win32com.client
import pandas as pd
import re
import os
import datetime

def limpiar_html(texto_sucio):
    if not texto_sucio: return ""
    texto = texto_sucio.replace('&nbsp;', ' ').replace('&amp;', '&').replace('&gt;', '>').replace('&lt;', '<')
    texto_limpio = re.sub(r'<[^>]+>', '', texto)
    return texto_limpio.replace('\r', '').replace('\n', '').strip()

def detectar_tipo_tabla(texto_previo):
    if not texto_previo: return "NORMAL"
    texto_upper = texto_previo.upper()
    idx_testeo = texto_upper.rfind("TESTEO")
    idx_afectacion = texto_upper.rfind("AFECTACION")
    if idx_afectacion == -1: idx_afectacion = texto_upper.rfind("AFECTACIÓN")

    if idx_testeo == -1 and idx_afectacion == -1: return "NORMAL"
    if idx_testeo > idx_afectacion: return "TESTEO"
    else: return "AFECTACION"

def verificar_excel_cerrado(ruta_excel):
    if os.path.exists(ruta_excel):
        try:
            with open(ruta_excel, "a"): pass
        except PermissionError: return False
    return True

def procesar_correos_bancarios_v8():
    archivo_excel = "Base_Fraude_Comercios_Final.xlsx"
    print("--- INICIANDO ESCANEO (VERSIÓN 8 - ORDENAMIENTO FANTASMA) ---")

    if not verificar_excel_cerrado(archivo_excel):
        print("❌ ERROR CRÍTICO: EL EXCEL ESTÁ ABIERTO. CIÉRRALO.")
        return

    try:
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        inbox = outlook.GetDefaultFolder(6).Folders("deteccion")
    except:
        print("Error conectando a Outlook.")
        return

    # 1. ORDENAMOS LA LECTURA DESDE OUTLOOK (Viejo -> Nuevo)
    items = inbox.Items
    items.Sort("[ReceivedTime]", False) 
    mensajes_filtrados = items.Restrict("[UnRead] = True")
    lista_mensajes = list(mensajes_filtrados)
    
    cantidad = len(lista_mensajes)
    print(f"Total de correos NO LEÍDOS: {cantidad}")
    if cantidad == 0:
        print("No hay nada pendiente.")
        return

    lista_datos = []
    mensajes_para_marcar = []

    # 2. PROCESAMIENTO
    for i, mensaje in enumerate(lista_mensajes):
        try:
            print(f"Leyendo correo {i+1}/{cantidad}...")
            html_body = mensaje.HTMLBody
            
            # --- CAPTURAMOS DATOS PARA VISUALIZAR ---
            fecha_obj = mensaje.ReceivedTime
            fecha_str = fecha_obj.strftime("%d/%m/%Y")
            hora_str = fecha_obj.strftime("%H:%M:%S")

            # --- CAPTURAMOS EL DATO "FANTASMA" PARA ORDENAR ---
            # Usamos el objeto original que contiene la fecha exacta
            # Convertimos a formato compatible con Pandas para evitar errores de zona horaria
            fecha_raw = pd.to_datetime(str(fecha_obj)).replace(tzinfo=None)

            tablas = list(re.finditer(r'<table[^>]*>(.*?)</table>', html_body, re.IGNORECASE | re.DOTALL))
            encontrado = False

            for match in tablas:
                contenido = match.group(1)
                texto_previo = html_body[:match.start()]
                tipo = detectar_tipo_tabla(texto_previo)
                
                filas = re.split(r'</tr>', contenido, flags=re.IGNORECASE)
                for fila in filas:
                    celdas = re.findall(r'<td[^>]*>(.*?)</td>', fila, re.IGNORECASE | re.DOTALL)
                    if len(celdas) < 2: continue
                    
                    c0 = limpiar_html(celdas[0])
                    c1 = limpiar_html(celdas[1])
                    
                    if not c0 or "NOMBRE COMERCIO" in c0.upper() or "TOTAL" in c0.upper(): continue
                    if "COD" in c1.upper() or "ENTRY" in c1.upper(): continue

                    lista_datos.append({
                        "Fecha": fecha_str,
                        "Hora": hora_str,
                        "Tipo": tipo,
                        "Nombre_Comercio": c0,
                        "Codigo_Comercio": c1,
                        "_orden_fantasma": fecha_raw # <--- ESTA ES LA CLAVE
                    })
                    encontrado = True
            
            if encontrado: mensajes_para_marcar.append(mensaje)

        except Exception as e:
            print(f"Error en correo {i+1}: {e}")
            continue

    # 3. GUARDADO INTELIGENTE
    if lista_datos:
        df_nuevo = pd.DataFrame(lista_datos)
        
        # Cargamos histórico si existe
        if os.path.exists(archivo_excel):
            try:
                df_antiguo = pd.read_excel(archivo_excel)
                
                # --- RECONSTRUIMOS LA COLUMNA FANTASMA PARA EL HISTÓRICO ---
                # Esto permite que los datos viejos también se ordenen bien
                df_antiguo["_orden_fantasma"] = pd.to_datetime(
                    df_antiguo["Fecha"].astype(str) + " " + df_antiguo["Hora"].astype(str),
                    dayfirst=True, errors='coerce'
                )
                
                df_final = pd.concat([df_antiguo, df_nuevo], ignore_index=True)
            except:
                df_final = df_nuevo
        else:
            df_final = df_nuevo

        # --- ORDENAMIENTO CRUCIAL ---
        print("Ordenando base de datos...")
        # kind='mergesort' es un algoritmo ESTABLE. 
        # Significa que si dos filas tienen la misma hora exacta (Testeo y Afectacion),
        # NO las cambia de lugar, respeta el orden en que las leímos.
        df_final = df_final.sort_values(by="_orden_fantasma", ascending=True, kind='mergesort')

        # --- LIMPIEZA FINAL ---
        # Borramos la columna fantasma antes de guardar para que no salga en el Excel
        df_final_guardar = df_final.drop(columns=["_orden_fantasma"])
        
        # Reordenamos columnas visibles
        cols = ["Fecha", "Hora", "Tipo", "Nombre_Comercio", "Codigo_Comercio"]
        df_final_guardar = df_final_guardar[cols]

        try:
            df_final_guardar.to_excel(archivo_excel, index=False)
            print(f"✅ ¡ÉXITO! Se guardaron {len(lista_datos)} registros ordenados.")
            
            # Marcar leídos
            for m in mensajes_para_marcar:
                try: m.UnRead = False; m.Save()
                except: pass
                
        except PermissionError:
            print("❌ ERROR: EL EXCEL SIGUE ABIERTO.")
    else:
        print("No se encontraron datos válidos.")

if __name__ == "__main__":
    procesar_correos_bancarios_v8()
