import pandas as pd
import pyodbc
import numpy as np
import warnings

# Ignoramos alertas de pandas para mantener la consola limpia
warnings.filterwarnings('ignore')

# ==============================================================================
# 1. CONFIGURACI√ìN Y CONEXI√ìN (Igual que antes)
# ==============================================================================
ruta_db = r"C:\Users\s4930359\The Bank of Nova Scotia\Flores Hilario, Marcial - BBDD\BBDD_VRM.accdb"
nombre_tabla = 'BBDD_VRM'
ruta_salida_parquet = r"C:\Users\s4930359\OneDrive - The Bank of Nova Scotia\HERRAMIENTAS\Data_VRM_Final.parquet"

print("üîÑ [1/5] Conectando a la Base de Datos...")

try:
    conn_str = (r'DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=' + ruta_db + ';')
    conn = pyodbc.connect(conn_str)
    query = f"SELECT * FROM [{nombre_tabla}]"
    df_ori = pd.read_sql(query, conn)
    conn.close()
    print(f"   ‚úÖ Datos cargados: {len(df_ori):,} filas.")
except Exception as e:
    print(f"   ‚ùå Error cr√≠tico de conexi√≥n: {e}")
    exit()

# ==============================================================================
# 2. LIMPIEZA INICIAL Y SELECCI√ìN DE COLUMNAS
# ==============================================================================
print("üßπ [2/5] Limpiando datos...")

# Lista de columnas exactas que necesitas (Basado en tu imagen)
columnas_finales = [
    'TARJETA', 'VISA TRANSSACTION ID',
    'Fecha', 'Dia_reporte', 'AnoMes_reporte', 'MONTO USD', 'TIPO DE MONEDA',
    'NOMBRE REGLA', 'CODIGO REGLA', 'RTD REGLA', 'CVV2',
    'CALIFICACION', 'Gestion', # <--- OJO: Esta es la clave del status
    'BIN', 'MCC', 'NOMBRE DE COMERCIO', 'CODIGO DE COMERCIO',
    'CODIGO PAIS', 'LOCALIDAD',
    'ENTRY MODE', 'ECI', 'Entidad',
    'COD REDP 59', 'TIPO DE TOKEN', 'NUMERO DE TOKEN'
]

# Creamos el DF de trabajo solo con lo necesario
# Usamos reindex para evitar error si alguna columna no existe en el Access
df = df_ori.reindex(columns=columnas_finales)

# A. Formato de Fecha
df['Fecha'] = pd.to_datetime(df['Fecha'], errors='coerce')

# B. Limpieza de la columna de Estado (Crucial para los flags)
# Asumimos que la columna en Access se llama 'CALIFICACION'
col_status = 'CALIFICACION'
df[col_status] = df[col_status].fillna('DESCONOCIDO').astype(str)
# Estandarizamos a May√∫sculas y sin espacios (Ej: " Good " -> "GOOD")
df['Status_Clean'] = df[col_status].str.upper().str.strip()

# ==============================================================================
# 3. L√ìGICA DE NEGOCIO: CATEGORIZACI√ìN (El Cerebro)
# ==============================================================================
print("üß† [3/5] Aplicando Reglas de Negocio...")

# --- A. Definici√≥n de Listas (Ajusta los textos si en tu base vienen en Espa√±ol) ---
# Seg√∫n tus fotos, en tu base vienen en INGL√âS ('GOOD', 'FRAUD', etc.)
estados_fraude = ['FRAUD', 'FRAUDE']
estados_fp     = ['GOOD', 'BUENA', 'BUENO']     # Falso Positivo confirmado
estados_pend   = ['PENDING', 'PENDIENTE']       # Dudoso
estados_nuevos = ['NEW', 'NUEVA', 'NUEVO']      # Sin trabajar

# --- B. Columna Legible para Filtros Visuales ---
conditions_cat = [
    df['Status_Clean'].isin(estados_fraude),
    df['Status_Clean'].isin(estados_fp),
    df['Status_Clean'].isin(estados_pend),
    df['Status_Clean'].isin(estados_nuevos)
]
choices_cat = ['Fraude', 'Buena (FP)', 'Pendiente', 'Nuevo']

df['Categoria_Final'] = np.select(conditions_cat, choices_cat, default='Otro')

# ==============================================================================
# 4. CREACI√ìN DE FLAGS PARA R√ÅTIOS Y KPIs (Lo nuevo que pediste)
# ==============================================================================
print("üö© [4/5] Calculando Indicadores de Eficiencia...")

# --- FLAG 1: TU KPI (% de Insulto / Falso Positivo Normal) ---
# L√≥gica: 
#   1 = Nos equivocamos (Buena o Pendiente)
#   0 = Acertamos (Fraude)
#   NaN = New (No cuenta para el promedio)
condiciones_insulto = [
    df['Status_Clean'].isin(estados_fp + estados_pend), # Error
    df['Status_Clean'].isin(estados_fraude),            # Acierto
    df['Status_Clean'].isin(estados_nuevos)             # Ignorar
]
# En Power BI: El PROMEDIO de esta columna ser√° tu % de Falso Positivo
df['Flag_Insulto_Pct'] = np.select(condiciones_insulto, [1, 0, np.nan], default=np.nan)


# --- FLAG 2: DENOMINADOR PARA RATIOS (Solo Fraudes) ---
# L√≥gica: 1 solo si es Fraude. Sirve para dividir.
df['Counter_Fraude'] = np.where(df['Status_Clean'].isin(estados_fraude), 1, 0)


# --- FLAG 3: NUMERADOR PARA RATIO ESPECIALISTA (Sin New) ---
# L√≥gica: 1 para todo lo que YA se trabaj√≥ (Excluye New).
# En Power BI: SUM(Counter_Trabajado) / SUM(Counter_Fraude) = Ratio del Especialista
df['Counter_Trabajado'] = np.where(~df['Status_Clean'].isin(estados_nuevos), 1, 0)


# --- FLAG 4: NUMERADOR GLOBAL (Para Ratio Total) ---
# Simplemente cuenta todo.
df['Counter_Total_Alertas'] = 1


# ==============================================================================
# 5. ENRIQUECIMIENTO Y EXPORTACI√ìN
# ==============================================================================
print("üöÄ [5/5] Enriqueciendo y Exportando...")

# A. Franja Horaria (Tal cual tu c√≥digo original)
def categorizar_hora(fecha):
    if pd.isnull(fecha): return 'Desconocido'
    h = fecha.hour
    if 0 <= h < 6: return 'Madrugada (0-6)'
    elif 6 <= h < 12: return 'Ma√±ana (6-12)'
    elif 12 <= h < 18: return 'Tarde (12-18)'
    else: return 'Noche (18-24)'

df['Franja_Horaria'] = df['Fecha'].apply(categorizar_hora)

# B. Lag Internacional
# Si el c√≥digo pais es PE, PER o 604 es NO, sino SI.
paises_locales = ['PE', 'PER', '604']
df['Es_Internacional'] = np.where(
    df['CODIGO PAIS'].astype(str).str.strip().isin(paises_locales), 
    'NO', 
    'SI'
)

# C. Guardado Final
try:
    df.to_parquet(ruta_salida_parquet, index=False)
    print(f"‚ú® √âXITO: Archivo exportado en: {ruta_salida_parquet}")
    print("   üìä Listo para conectar a Power BI.")
except Exception as e:
    print(f"‚ùå Error al guardar Parquet: {e}")

## enrriquecimiento
# ==============================================================================
# SECCI√ìN 4.X: ENRIQUECIMIENTO DE DATOS (BINES Y ENTRY MODE)
# ==============================================================================

print("üìö [4.1] Estandarizando Entry Mode y Aplicando Diccionario de BINES...")

# 1. CORRECCI√ìN ENTRY MODE (Tu confirmaci√≥n)
# Forzamos a que siempre tenga 2 d√≠gitos (ej: '1' -> '01')
if 'POS_ENTRY_MODE' in df.columns:
    df['POS_ENTRY_MODE'] = df['POS_ENTRY_MODE'].astype(str).str.split('.').str[0].str.zfill(2)

# ------------------------------------------------------------------------------
# 2. DICCIONARIO MAESTRO DE BINES (Aqu√≠ pegas tu data real)
# Estructura: 'BIN': ['EMISOR', 'MARCA', 'DETALLE']
# ------------------------------------------------------------------------------
BASE_BINES = {
    # 'BIN'   : ['EMISOR',       'MARCA',      'DETALLE/GAMA']
    '455123': ['Banco Uno',    'Visa',       'Platinum'],
    '411111': ['Banco Uno',    'Visa',       'Cl√°sica'],
    '522222': ['Banco Dos',    'Mastercard', 'Black'],
    '555555': ['Banco Dos',    'Mastercard', 'Gold'],
    '499999': ['Banco Uno',    'Visa',       'Empresarial'],
    # ... PEGA AQU√ç ABAJO TUS DEM√ÅS BINES SIGUIENDO EL MISMO FORMATO ...
}

# ------------------------------------------------------------------------------
# 3. FUNCI√ìN PARA BUSCAR EN EL DICCIONARIO
# ------------------------------------------------------------------------------
def enriquecer_bin(bin_code):
    bin_code = str(bin_code)
    
    # A. Buscamos si el BIN exacto existe en tu diccionario
    if bin_code in BASE_BINES:
        datos = BASE_BINES[bin_code]
        return datos[0], datos[1], datos[2] # Retorna (Emisor, Marca, Detalle)
    
    # B. Si NO est√° en el diccionario, aplicamos l√≥gica por defecto
    else:
        # L√≥gica de Marca por defecto (4=Visa, 5=MC)
        if bin_code.startswith('4'):
            marca_default = 'Visa'
        elif bin_code.startswith('5'):
            marca_default = 'Mastercard'
        else:
            marca_default = 'Otro'
            
        return 'Otros Bancos', marca_default, 'Est√°ndar'

# ------------------------------------------------------------------------------
# 4. APLICAR LA MAGIA AL DATAFRAME
# ------------------------------------------------------------------------------

# Aseguramos que existe la columna BIN
df['BIN'] = df['TARJETA'].astype(str).str[:6]

# Creamos las 3 columnas nuevas de un solo golpe
# Esto aplica la funci√≥n fila por fila
datos_enriquecidos = df['BIN'].apply(lambda x: pd.Series(enriquecer_bin(x)))

# Asignamos nombres a las columnas nuevas
df['Banco_Emisor'] = datos_enriquecidos[0]
df['Marca_Tarjeta'] = datos_enriquecidos[1]
df['Segmento_Tarjeta'] = datos_enriquecidos[2] # Aqu√≠ tendr√°s Platinum, Black, etc.

print("‚úÖ BINES procesados. Nuevas columnas: Banco_Emisor, Marca_Tarjeta, Segmento_Tarjeta")
##################################
########### mejroar entry mode#####
##################################
# ==============================================================================
# 4.1 TRADUCCI√ìN MAESTRA DE ENTRY MODE (Basada en Diccionario ISO/VRM)
# ==============================================================================

print("üìö Interpretando Entry Mode seg√∫n diccionario espec√≠fico...")

# 1. LIMPIEZA INICIAL (Sin zfill)
# Convertimos a string y quitamos el ".0" si Excel lo puso, pero NO agregamos ceros.
# As√≠ '1' se queda como '1' y '01' se queda como '01'.
if 'POS_ENTRY_MODE' in df.columns:
    df['POS_ENTRY_MODE'] = df['POS_ENTRY_MODE'].astype(str).str.replace('.0', '', regex=False).str.strip()

# 2. DICCIONARIO EXACTO (Transcrito de tu imagen)
diccionario_entry_mode = {
    # --- SUBFIELD 2: CAPACIDAD DE PIN (C√≥digos de 1 d√≠gito) ---
    '0': 'PIN: No especificado / Desconocido',
    '1': 'PIN: Terminal TIENE teclado (PIN Capable)',
    '2': 'PIN: Terminal NO TIENE teclado',
    '8': 'PIN: Tiene teclado pero est√° inactivo/ca√≠do',

    # --- SUBFIELD 1: MODO DE ENTRADA PAN (C√≥digos de 2 d√≠gitos) ---
    '00': 'Desconocido (Unknown)',
    '01': 'Manual (PAN Manual Entry) ‚ö†Ô∏è',
    '02': 'Banda Magn√©tica (Auto-entry)',
    '03': 'C√≥digo de Barras',
    '04': 'OCR (Lector √ìptico)',
    '05': 'Chip (Insertado / ICC)',
    '06': 'Chip (Contactless Mapping)', # Poco com√∫n pero existe
    '07': 'Contactless (M/Chip)',
    '08': 'Contactless (M/Chip Mapping)',
    '09': 'E-Commerce con Chip Remoto',
    '10': 'Card on File (Credencial Guardada)',
    
    # Casos especiales de Fallback y H√≠bridos
    '79': 'H√≠brido (Chip fall√≥ en conexi√≥n)',
    '80': 'Fallback (Chip fall√≥ -> Banda Magn√©tica) ‚ö†Ô∏è',
    '81': 'E-Commerce (Incluyendo Chip)',
    '82': 'Server Entry (Issuer/Vendor)',
    
    # Bandas y Contactless Legacy
    '90': 'Banda Magn√©tica (Full Track)',
    '91': 'Contactless (Simulaci√≥n Banda / Stripe)',
    '92': 'Contactless (Mapping Service)',
    '95': 'Chip con CVV poco confiable (Visa Only)'
}

# 3. FUNCI√ìN DE TRADUCCI√ìN
def traducir_entry_mode(valor):
    # Buscamos la coincidencia exacta
    if valor in diccionario_entry_mode:
        return diccionario_entry_mode[valor]
    
    # Si no est√°, devolvemos el c√≥digo original para que investigues
    return f"C√≥digo Desconocido ({valor})"

# 4. APLICAMOS LA TRADUCCI√ìN
df['Desc_Entry_Mode'] = df['POS_ENTRY_MODE'].apply(traducir_entry_mode)

# 5. GENERAMOS LA COLUMNA SIMPLIFICADA "PRESENTE vs NO PRESENTE"
# Usamos la descripci√≥n traducida para agrupar
def definir_presencia_v2(descripcion):
    desc = descripcion.lower()
    
    # Palabras clave de PRESENCIA F√çSICA
    if any(x in desc for x in ['chip', 'banda', 'contactless', 'pin:', 'manual']):
        return 'Tarjeta Presente (CP)'
    
    # Palabras clave de NO PRESENTE
    elif any(x in desc for x in ['e-commerce', 'server', 'file']):
        return 'No Presente (CNP)'
        
    return 'Revisar / Otros'

df['Tipo_Presencia'] = df['Desc_Entry_Mode'].apply(definir_presencia_v2)

print("‚úÖ Entry Mode traducido correctamente. Se respet√≥ diferencia entre 1 y 01.")
