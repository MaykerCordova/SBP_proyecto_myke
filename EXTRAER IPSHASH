import win32com.client
import pandas as pd
import re
import os
import datetime

# --- CONFIGURACIÓN DE USUARIO ---
# TRUE = Guarda TODO (Hashes, IPs y Wallets mezclados).
# FALSE = Si encuentra la palabra "Wallet ID", CORTA el análisis ahí para no guardar lo que siga.
INCLUIR_WALLET_IDS = False 

def limpiar_html_a_texto(html_sucio):
    """Limpia el HTML para dejar solo texto legible."""
    if not html_sucio: return ""
    texto = html_sucio.replace('<br>', ' ').replace('</td>', ' ').replace('</div>', ' ')
    texto_limpio = re.sub(r'<[^>]+>', ' ', texto)
    texto_final = texto_limpio.replace('&nbsp;', ' ').replace('\r', '').replace('\n', '')
    return re.sub(' +', ' ', texto_final).strip()

def verificar_excel_cerrado(ruta_excel):
    """Pilar 1: Seguridad de Archivo."""
    if os.path.exists(ruta_excel):
        try:
            with open(ruta_excel, "a"): pass
        except PermissionError: return False
    return True

def procesar_correos_ips_hashes_v3():
    print(f"--- INICIANDO EXTRACCIÓN (Mode Wallet ID: {'INCLUIDO' if INCLUIR_WALLET_IDS else 'EXCLUIDO'}) ---")
    
    archivo_excel = "Base_IPs_Hashes.xlsx"
    
    # 1. SEGURIDAD DE ARCHIVO
    if not verificar_excel_cerrado(archivo_excel):
        print("❌ ERROR CRÍTICO: El Excel está abierto. Ciérralo y vuelve a ejecutar.")
        return

    # 2. CONEXIÓN OUTLOOK
    try:
        outlook = win32com.client.Dispatch("Outlook.Application").GetNamespace("MAPI")
        inbox = outlook.GetDefaultFolder(6)
        carpeta_destino = inbox.Folders("ips_Hash") 
    except Exception as e:
        print("Error: No se encuentra la carpeta 'ips_Hash'. Verifica el nombre.")
        return

    # --- ORDENAMIENTO (Viejo -> Nuevo) ---
    items = carpeta_destino.Items
    items.Sort("[ReceivedTime]", False) 
    mensajes_filtrados = items.Restrict("[UnRead] = True")
    
    lista_mensajes = list(mensajes_filtrados)
    cantidad = len(lista_mensajes)
    print(f"Correos pendientes encontrados: {cantidad}")

    if cantidad == 0:
        print("No hay nada pendiente.")
        return

    todos_los_hashes_nuevos = []
    todos_los_ips_nuevos = []
    mensajes_para_marcar = []

    # --- REGEX MEJORADO (Tu solicitud) ---
    regex_ip = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    
    # Explicación Regex Hash:
    # Opción 1: [a-fA-F0-9]{16,}  -> Hexadecimal continuo largo (ej. d9ae64...)
    # Opción 2: [a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12} -> Formato GUID con guiones (ej. 55B9CA70-...)
    regex_hash = r'\b(?:[a-fA-F0-9]{16,}|[a-fA-F0-9]{8}(?:-[a-fA-F0-9]{4}){3}-[a-fA-F0-9]{12})\b'

    # 3. PROCESAR CADA CORREO
    for i, mensaje in enumerate(lista_mensajes):
        try:
            print(f"Procesando correo {i+1}/{cantidad}...")
            
            fecha_obj = mensaje.ReceivedTime
            fecha_str = fecha_obj.strftime("%d/%m/%Y")
            hora_str = fecha_obj.strftime("%H:%M:%S")
            fecha_raw = pd.to_datetime(str(fecha_obj)).replace(tzinfo=None) # Pilar 3

            texto_cuerpo = limpiar_html_a_texto(mensaje.HTMLBody)
            
            # --- LA LÓGICA DE LA "TIJERA" ---
            # Si el usuario NO quiere Wallets, cortamos el texto donde empiece la sección de Wallets.
            if not INCLUIR_WALLET_IDS:
                # Buscamos "Wallet ID" (o variaciones comunes) ignorando mayúsculas
                match_wallet = re.search(r"WALLET ID", texto_cuerpo, re.IGNORECASE)
                if match_wallet:
                    # CORTAMOS EL TEXTO: Nos quedamos solo con lo que está ANTES de "Wallet ID"
                    posicion_corte = match_wallet.start()
                    print(f"  > Se detectó sección Wallet ID. Cortando texto para ignorarla...")
                    texto_cuerpo = texto_cuerpo[:posicion_corte]
                    # Ahora 'texto_cuerpo' ya no tiene la parte del Wallet, pero SÍ tiene la de Hash/IP

            # Búsqueda de patrones (Ahora segura)
            hashes_encontrados = re.findall(regex_hash, texto_cuerpo)
            ips_encontradas = re.findall(regex_ip, texto_cuerpo)
            
            encontrado_algo = False

            # Procesar Hashes
            for h in hashes_encontrados:
                if "1e2932eb0f962f6e" in h: continue # Tu filtro de ejemplo
                
                todos_los_hashes_nuevos.append({
                    "Fecha": fecha_str,
                    "Hora": hora_str,
                    "Hash_Detectado": h,
                    "_orden_fantasma": fecha_raw
                })
                encontrado_algo = True
                
            # Procesar IPs
            for ip in ips_encontradas:
                 if ip.startswith("127.0") or ip.startswith("10."): continue
                 todos_los_ips_nuevos.append({
                     "Fecha": fecha_str,
                     "Hora": hora_str,
                     "IP_Detectada": ip,
                     "_orden_fantasma": fecha_raw
                 })
                 encontrado_algo = True

            # Si encontramos datos O si era un correo válido (aunque vacío de datos útiles)
            # lo marcamos para que no se atasque en la bandeja
            if encontrado_algo or (not hashes_encontrados and not ips_encontradas):
                mensajes_para_marcar.append(mensaje)

        except Exception as e:
            print(f"Error en correo {i+1}: {e}")
            continue

    # 4. GUARDAR Y ORDENAR (LÓGICA BLINDADA)
    df_hashes_nuevos = pd.DataFrame(todos_los_hashes_nuevos)
    df_ips_nuevos = pd.DataFrame(todos_los_ips_nuevos)

    if df_hashes_nuevos.empty and df_ips_nuevos.empty:
        print("No se encontraron datos nuevos.")
        # Opcional: Descomentar si quieres limpiar la bandeja incluso si no hubo datos
        # for m in mensajes_para_marcar: m.UnRead = False; m.Save()
        return

    try:
        # FASE DE CARGA (Preservar histórico)
        df_hashes_final = pd.DataFrame()
        df_ips_final = pd.DataFrame()
        
        def ordenar_con_fantasma(df):
            if not df.empty and "_orden_fantasma" in df.columns:
                mask = df["_orden_fantasma"].isna()
                if mask.any():
                    df.loc[mask, "_orden_fantasma"] = pd.to_datetime(
                        df.loc[mask, "Fecha"].astype(str) + " " + df.loc[mask, "Hora"].astype(str),
                        dayfirst=True, errors='coerce'
                    )
                df = df.sort_values(by="_orden_fantasma", ascending=True, kind='mergesort')
                return df.drop(columns=["_orden_fantasma"])
            return df

        if os.path.exists(archivo_excel):
            try: df_hashes_final = pd.read_excel(archivo_excel, sheet_name='Hashes')
            except: pass 
            try: df_ips_final = pd.read_excel(archivo_excel, sheet_name='IPs')
            except: pass 

        if not df_hashes_nuevos.empty:
            df_hashes_final = pd.concat([df_hashes_final, df_hashes_nuevos], ignore_index=True)
        if not df_ips_nuevos.empty:
            df_ips_final = pd.concat([df_ips_final, df_ips_nuevos], ignore_index=True)

        df_hashes_final = ordenar_con_fantasma(df_hashes_final)
        df_ips_final = ordenar_con_fantasma(df_ips_final)

        # GUARDAR
        print("Guardando Excel...")
        with pd.ExcelWriter(archivo_excel, engine='openpyxl', mode='w') as writer:
            if not df_hashes_final.empty:
                df_hashes_final.to_excel(writer, sheet_name='Hashes', index=False)
            if not df_ips_final.empty:
                df_ips_final.to_excel(writer, sheet_name='IPs', index=False)

        print(f"✅ ¡ÉXITO! Base actualizada.")
        
        # FASE DE TRANSACCIONALIDAD (Pilar 2)
        print("Actualizando correos a LEÍDO...")
        for m in mensajes_para_marcar:
            try: m.UnRead = False; m.Save()
            except: pass
            
    except PermissionError:
        print("❌ ERROR: El Excel sigue abierto. Ciérralo y reintenta.")
    except Exception as e:
        print(f"Error guardando Excel: {e}")

if __name__ == "__main__":
    procesar_correos_ips_hashes_v3()
